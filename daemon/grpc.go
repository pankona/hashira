package daemon

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"

	"github.com/pankona/hashira/service"
)

const (
	taskBucket     = "taskBucket"
	priorityBucket = "priorityBucket"
)

// Create creates a new task
func (d *Daemon) Create(ctx context.Context, com *service.CommandCreate) (*service.ResultCreate, error) {
	t := com.Task
	buf, err := json.Marshal(t)
	if err != nil {
		return nil, errors.New("failed to create a new task: " + err.Error())
	}

	p, err := d.retrievePriority()
	if err != nil {
		return nil, err
	}

	// specify empty id.
	// expect an id is automatically generated by database itself
	id, err := d.DB.Save(taskBucket, "", buf)
	if err != nil {
		return nil, errors.New("failed to save new task on database: " + err.Error())
	}

	// put new task on first place
	p[t.Place.String()].Ids = append([]string{id}, p[t.Place.String()].Ids...)

	_, err = d.updatePriority(p)
	if err != nil {
		return nil, err
	}

	result := &service.ResultCreate{Task: t}
	return result, nil
}

// Update updates an existing task
func (d *Daemon) Update(ctx context.Context, com *service.CommandUpdate) (*service.ResultUpdate, error) {
	if com.Task == nil {
		return nil, errors.New("failed to update a task because specified task is nil")
	}

	buf, err := json.Marshal(com.Task)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal specified task: %s", err.Error())
	}

	_, err = d.DB.Save(taskBucket, com.Task.Id, buf)
	if err != nil {
		return nil, fmt.Errorf("failed to save update of task: %s", err.Error())
	}

	return &service.ResultUpdate{
		Task: com.Task,
	}, nil
}

// Delete deletes an existing task
func (d *Daemon) Delete(ctx context.Context, com *service.CommandDelete) (*service.ResultDelete, error) {
	buf, err := d.DB.Load(taskBucket, com.Id)
	if err != nil {
		return nil, err
	}

	t := &service.Task{Id: com.Id}
	err = json.Unmarshal(buf, t)
	if err != nil {
		return nil, err
	}

	t.IsDeleted = true
	buf, err = json.Marshal(t)
	if err != nil {
		return nil, err
	}

	_, err = d.DB.Save(taskBucket, com.Id, buf)
	return &service.ResultDelete{Task: t}, err
}

// Delete deletes an existing task
func (d *Daemon) PhysicalDelete(ctx context.Context, com *service.CommandPhysicalDelete) (*service.ResultPhysicalDelete, error) {
	err := d.DB.PhysicalDelete(taskBucket, com.Id)
	if err != nil {
		return nil, err
	}
	return &service.ResultPhysicalDelete{}, nil
}

type deletedItem int

const (
	excludeDeleted = iota
	includeDeleted
)

// Retrieve retrieves all existing tasks (but not deleted tasks)
func (d *Daemon) Retrieve(ctx context.Context, com *service.CommandRetrieve) (*service.ResultRetrieve, error) {
	deletedItem := deletedItem(excludeDeleted)
	if !com.ExcludeDeleted {
		deletedItem = includeDeleted
	}
	tasks, err := d.retrieve(deletedItem)
	if err != nil {
		return nil, errors.New("failed to retrieve tasks: " + err.Error())
	}

	result := &service.ResultRetrieve{
		Tasks: tasks,
	}

	return result, err
}

func (d *Daemon) retrieve(deletedItem deletedItem) (map[string]*service.Task, error) {
	tasks := make(map[string]*service.Task)

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if deletedItem == excludeDeleted && t.IsDeleted {
			return nil
		}

		tasks[t.Id] = t
		return nil
	})
	if err != nil {
		return nil, err
	}

	return tasks, nil
}

// returns map[Place.String()][]*service.Task
func (d *Daemon) retrieveTaskMap() (map[string]map[string]*service.Task, error) {
	places := []service.Place{
		service.Place_BACKLOG,
		service.Place_TODO,
		service.Place_DOING,
		service.Place_DONE,
	}

	m := make(map[string]map[string]*service.Task)
	for _, v := range places {
		m[v.String()] = make(map[string]*service.Task)
	}

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if t.IsDeleted {
			return nil
		}

		m[t.Place.String()][t.Id] = t
		return nil
	})
	if err != nil {
		return nil, err
	}

	return m, nil
}

// UpdatePriority updates priority array
func (d *Daemon) UpdatePriority(
	ctx context.Context,
	com *service.CommandUpdatePriority) (*service.ResultUpdatePriority, error) {

	p, err := d.updatePriority(com.Priorities)

	return &service.ResultUpdatePriority{Priorities: p}, err
}

func (d *Daemon) updatePriority(p map[string]*service.Priority) (map[string]*service.Priority, error) {
	buf, err := json.Marshal(p)
	if err != nil {
		return nil, errors.New("failed to marshal CommandUpdatePriority into json: " + err.Error())
	}

	_, err = d.DB.Save(priorityBucket, "priority", buf)
	if err != nil {
		return nil, errors.New("failed to save priority on database: " + err.Error())
	}

	return p, nil
}

func lookupTaskByID(tasks map[string]map[string]*service.Task, id string) *service.Task {
	for _, t := range tasks {
		if _, ok := t[id]; ok {
			return t[id]
		}
	}
	return nil
}

// RetrievePriority returns priority array
func (d *Daemon) RetrievePriority(
	ctx context.Context,
	com *service.CommandRetrievePriority) (*service.ResultRetrievePriority, error) {

	p, err := d.retrievePriority()

	return &service.ResultRetrievePriority{Priorities: p}, err
}

func (d *Daemon) retrievePriority() (map[string]*service.Priority, error) {
	priorities, err := d.retrievePriorityMap()
	if err != nil {
		return nil, err
	}

	tasks, err := d.retrieveTaskMap()
	if err != nil {
		return nil, err
	}

	// remove ID from priorities if there's no task which has the ID
	for _, priority := range priorities {
		for _, id := range priority.Ids {
			if lookupTaskByID(tasks, id) == nil {
				priority.Ids = remove(priority.Ids, id)
			}
		}
	}

	// repair IDs to keep consistency between priorities and tasks
	for k := range tasks {
		if _, ok := priorities[k]; !ok {
			priorities[k] = &service.Priority{
				Ids: make([]string, 0),
			}
		}
		priorities[k].Ids = repair(priorities[k].Ids, tasks[k])
	}

	return priorities, nil
}

func repair(dst []string, tasks map[string]*service.Task) []string {
	if len(dst) == len(tasks) {
		return dst
	}

	m := make(map[string]struct{})

	for i, id := range dst {
		if _, ok := tasks[id]; ok {
			m[dst[i]] = struct{}{}
		}
	}

	if len(dst) < len(tasks) {
		// must cover lacked dst
		for _, v := range tasks {
			if _, ok := m[v.Id]; !ok {
				dst = append(dst, v.Id)
			}
		}
	}

	if len(dst) > len(tasks) {
		// must remove extra IDs
		for _, v := range dst {
			if _, ok := m[v]; !ok {
				dst = remove(dst, v)
			}
		}
	}

	return dst
}

func remove(ids []string, id string) []string {
	ret := make([]string, len(ids))
	var index int
	for _, v := range ids {
		if v == id {
			continue
		}
		ret[index] = v
		index++
	}
	return ret[:index]
}

func (d *Daemon) retrievePriorityMap() (map[string]*service.Priority, error) {
	m := make(map[string]*service.Priority)

	buf, err := d.DB.Load(priorityBucket, "priority")
	if err != nil {
		return nil, err
	}

	// DB loaded but it is empty. treat as regular case.
	if len(buf) == 0 {
		return map[string]*service.Priority{}, nil
	}

	err = json.Unmarshal(buf, &m)
	if err != nil {
		log.Printf("failed to unmarshal loaded data into service.Priority: %v", err)
	}

	if len(m) == 0 {
		return map[string]*service.Priority{}, nil
	}

	return m, nil
}
