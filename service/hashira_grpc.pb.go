// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package service

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// HashiraClient is the client API for Hashira service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HashiraClient interface {
	Create(ctx context.Context, in *CommandCreate, opts ...grpc.CallOption) (*ResultCreate, error)
	Update(ctx context.Context, in *CommandUpdate, opts ...grpc.CallOption) (*ResultUpdate, error)
	Delete(ctx context.Context, in *CommandDelete, opts ...grpc.CallOption) (*ResultDelete, error)
	PhysicalDelete(ctx context.Context, in *CommandPhysicalDelete, opts ...grpc.CallOption) (*ResultPhysicalDelete, error)
	Retrieve(ctx context.Context, in *CommandRetrieve, opts ...grpc.CallOption) (*ResultRetrieve, error)
	UpdatePriority(ctx context.Context, in *CommandUpdatePriority, opts ...grpc.CallOption) (*ResultUpdatePriority, error)
	RetrievePriority(ctx context.Context, in *CommandRetrievePriority, opts ...grpc.CallOption) (*ResultRetrievePriority, error)
}

type hashiraClient struct {
	cc grpc.ClientConnInterface
}

func NewHashiraClient(cc grpc.ClientConnInterface) HashiraClient {
	return &hashiraClient{cc}
}

func (c *hashiraClient) Create(ctx context.Context, in *CommandCreate, opts ...grpc.CallOption) (*ResultCreate, error) {
	out := new(ResultCreate)
	err := c.cc.Invoke(ctx, "/service.Hashira/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) Update(ctx context.Context, in *CommandUpdate, opts ...grpc.CallOption) (*ResultUpdate, error) {
	out := new(ResultUpdate)
	err := c.cc.Invoke(ctx, "/service.Hashira/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) Delete(ctx context.Context, in *CommandDelete, opts ...grpc.CallOption) (*ResultDelete, error) {
	out := new(ResultDelete)
	err := c.cc.Invoke(ctx, "/service.Hashira/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) PhysicalDelete(ctx context.Context, in *CommandPhysicalDelete, opts ...grpc.CallOption) (*ResultPhysicalDelete, error) {
	out := new(ResultPhysicalDelete)
	err := c.cc.Invoke(ctx, "/service.Hashira/PhysicalDelete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) Retrieve(ctx context.Context, in *CommandRetrieve, opts ...grpc.CallOption) (*ResultRetrieve, error) {
	out := new(ResultRetrieve)
	err := c.cc.Invoke(ctx, "/service.Hashira/Retrieve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) UpdatePriority(ctx context.Context, in *CommandUpdatePriority, opts ...grpc.CallOption) (*ResultUpdatePriority, error) {
	out := new(ResultUpdatePriority)
	err := c.cc.Invoke(ctx, "/service.Hashira/UpdatePriority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *hashiraClient) RetrievePriority(ctx context.Context, in *CommandRetrievePriority, opts ...grpc.CallOption) (*ResultRetrievePriority, error) {
	out := new(ResultRetrievePriority)
	err := c.cc.Invoke(ctx, "/service.Hashira/RetrievePriority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HashiraServer is the server API for Hashira service.
// All implementations must embed UnimplementedHashiraServer
// for forward compatibility
type HashiraServer interface {
	Create(context.Context, *CommandCreate) (*ResultCreate, error)
	Update(context.Context, *CommandUpdate) (*ResultUpdate, error)
	Delete(context.Context, *CommandDelete) (*ResultDelete, error)
	PhysicalDelete(context.Context, *CommandPhysicalDelete) (*ResultPhysicalDelete, error)
	Retrieve(context.Context, *CommandRetrieve) (*ResultRetrieve, error)
	UpdatePriority(context.Context, *CommandUpdatePriority) (*ResultUpdatePriority, error)
	RetrievePriority(context.Context, *CommandRetrievePriority) (*ResultRetrievePriority, error)
	mustEmbedUnimplementedHashiraServer()
}

// UnimplementedHashiraServer must be embedded to have forward compatible implementations.
type UnimplementedHashiraServer struct {
}

func (UnimplementedHashiraServer) Create(context.Context, *CommandCreate) (*ResultCreate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (UnimplementedHashiraServer) Update(context.Context, *CommandUpdate) (*ResultUpdate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedHashiraServer) Delete(context.Context, *CommandDelete) (*ResultDelete, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedHashiraServer) PhysicalDelete(context.Context, *CommandPhysicalDelete) (*ResultPhysicalDelete, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PhysicalDelete not implemented")
}
func (UnimplementedHashiraServer) Retrieve(context.Context, *CommandRetrieve) (*ResultRetrieve, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Retrieve not implemented")
}
func (UnimplementedHashiraServer) UpdatePriority(context.Context, *CommandUpdatePriority) (*ResultUpdatePriority, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePriority not implemented")
}
func (UnimplementedHashiraServer) RetrievePriority(context.Context, *CommandRetrievePriority) (*ResultRetrievePriority, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RetrievePriority not implemented")
}
func (UnimplementedHashiraServer) mustEmbedUnimplementedHashiraServer() {}

// UnsafeHashiraServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HashiraServer will
// result in compilation errors.
type UnsafeHashiraServer interface {
	mustEmbedUnimplementedHashiraServer()
}

func RegisterHashiraServer(s grpc.ServiceRegistrar, srv HashiraServer) {
	s.RegisterService(&Hashira_ServiceDesc, srv)
}

func _Hashira_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandCreate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).Create(ctx, req.(*CommandCreate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandUpdate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).Update(ctx, req.(*CommandUpdate))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandDelete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).Delete(ctx, req.(*CommandDelete))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_PhysicalDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandPhysicalDelete)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).PhysicalDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/PhysicalDelete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).PhysicalDelete(ctx, req.(*CommandPhysicalDelete))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_Retrieve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRetrieve)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).Retrieve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/Retrieve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).Retrieve(ctx, req.(*CommandRetrieve))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_UpdatePriority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandUpdatePriority)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).UpdatePriority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/UpdatePriority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).UpdatePriority(ctx, req.(*CommandUpdatePriority))
	}
	return interceptor(ctx, in, info, handler)
}

func _Hashira_RetrievePriority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CommandRetrievePriority)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HashiraServer).RetrievePriority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.Hashira/RetrievePriority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HashiraServer).RetrievePriority(ctx, req.(*CommandRetrievePriority))
	}
	return interceptor(ctx, in, info, handler)
}

// Hashira_ServiceDesc is the grpc.ServiceDesc for Hashira service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Hashira_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "service.Hashira",
	HandlerType: (*HashiraServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Hashira_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Hashira_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Hashira_Delete_Handler,
		},
		{
			MethodName: "PhysicalDelete",
			Handler:    _Hashira_PhysicalDelete_Handler,
		},
		{
			MethodName: "Retrieve",
			Handler:    _Hashira_Retrieve_Handler,
		},
		{
			MethodName: "UpdatePriority",
			Handler:    _Hashira_UpdatePriority_Handler,
		},
		{
			MethodName: "RetrievePriority",
			Handler:    _Hashira_RetrievePriority_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hashira.proto",
}
