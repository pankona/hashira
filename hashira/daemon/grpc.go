package daemon

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"

	"github.com/pankona/hashira/service"
)

const (
	taskBucket     = "taskBucket"
	priorityBucket = "priorityBucket"
)

// Create creates a new task
func (d *Daemon) Create(ctx context.Context, cc *service.CommandCreate) (*service.ResultCreate, error) {
	t := &service.Task{
		Name:      cc.GetName(),
		Place:     service.Place_BACKLOG,
		IsDeleted: false,
	}
	buf, err := json.Marshal(t)
	if err != nil {
		return nil, errors.New("failed to create a new task: " + err.Error())
	}

	// specify empty id.
	// expect an id is automatically generated by database itself
	err = d.DB.Save(taskBucket, "", buf)
	if err != nil {
		return nil, errors.New("failed to save new task on database: " + err.Error())
	}

	result := &service.ResultCreate{Task: t}
	return result, nil
}

// Update updates an existing task
func (d *Daemon) Update(context.Context, *service.CommandUpdate) (*service.ResultUpdate, error) {
	// TODO: implement
	return nil, nil
}

// Delete deletes an existing task
func (d *Daemon) Delete(ctx context.Context, cd *service.CommandDelete) (*service.ResultDelete, error) {
	buf, err := d.DB.Load(taskBucket, cd.Id)
	if err != nil {
		// TODO: error handling
	}

	t := &service.Task{Id: cd.Id}
	err = json.Unmarshal(buf, t)
	if err != nil {
		// TODO: error handling
	}

	t.IsDeleted = true
	buf, err = json.Marshal(t)
	if err != nil {
		// TODO: error handling
	}

	return &service.ResultDelete{Task: t}, d.DB.Save(taskBucket, cd.Id, buf)
}

// Retrieve retrieves all existing tasks
func (d *Daemon) Retrieve(ctx context.Context, cr *service.CommandRetrieve) (*service.ResultRetrieve, error) {
	tasks, err := d.retrieve()
	if err != nil {
		return nil, errors.New("failed to retrieve tasks: " + err.Error())
	}

	result := &service.ResultRetrieve{
		Tasks: tasks,
	}

	return result, err
}

func (d *Daemon) retrieve() ([]*service.Task, error) {
	tasks := make([]*service.Task, 0)

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		tasks = append(tasks, t)
		return nil
	})
	if err != nil {
		return nil, err
	}

	return tasks, nil
}

func (d *Daemon) UpdatePriority(ctx context.Context, cup *service.CommandUpdatePriority) (*service.ResultUpdatePriority, error) {
	p := service.Priority{
		Place: cup.Place,
		Ids:   cup.Ids,
	}
	buf, err := json.Marshal(p)
	if err != nil {
		return nil, errors.New("failed to marshal CommandUpdatePriority into json: " + err.Error())
	}

	err = d.DB.Save(priorityBucket, cup.Place.String(), buf)
	if err != nil {
		return nil, errors.New("failed to save priority on database: " + err.Error())
	}

	result, err := d.retrievePriority(cup.Place)
	return &service.ResultUpdatePriority{
		Place: result.Place,
		Ids:   result.Ids,
	}, err
}

func (d *Daemon) RetrievePriority(ctx context.Context, crp *service.CommandRetrievePriority) (*service.ResultRetrievePriority, error) {
	result, err := d.retrievePriority(crp.Place)
	return &service.ResultRetrievePriority{
		Place: result.Place,
		Ids:   result.Ids,
	}, err
}

func (d *Daemon) retrievePriority(place service.Place) (*service.ResultRetrievePriority, error) {
	buf, err := d.DB.Load(priorityBucket, place.String())
	if err != nil {
		return nil, err
	}

	p := &service.Priority{}
	err = json.Unmarshal(buf, p)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal loaded data into service.Priority: %s", err.Error())
	}

	return p, nil
}
