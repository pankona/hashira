package daemon

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"log"

	"github.com/pankona/hashira/service"
)

const (
	taskBucket     = "taskBucket"
	priorityBucket = "priorityBucket"
)

var places = []service.Place{
	service.Place_BACKLOG,
	service.Place_TODO,
	service.Place_DOING,
	service.Place_DONE,
}

var lookupPlaceByName = map[string]service.Place{
	service.Place_BACKLOG.String(): service.Place_BACKLOG,
	service.Place_TODO.String():    service.Place_TODO,
	service.Place_DOING.String():   service.Place_DOING,
	service.Place_DONE.String():    service.Place_DONE,
}

// Create creates a new task
func (d *Daemon) Create(ctx context.Context, com *service.CommandCreate) (*service.ResultCreate, error) {
	t := com.Task
	buf, err := json.Marshal(t)
	if err != nil {
		return nil, errors.New("failed to create a new task: " + err.Error())
	}

	p, err := d.retrievePriority()
	if err != nil {
		return nil, err
	}

	// specify empty id.
	// expect an id is automatically generated by database itself
	id, err := d.DB.Save(taskBucket, "", buf)
	if err != nil {
		return nil, errors.New("failed to save new task on database: " + err.Error())
	}

	// put new task on first place
	p[t.Place.String()].Ids = append([]string{id}, p[t.Place.String()].Ids...)

	priorities := make([]*service.Priority, 0)
	for _, v := range p {
		priorities = append(priorities, v)
	}

	_, err = d.updatePriority(priorities)
	if err != nil {
		return nil, err
	}

	result := &service.ResultCreate{Task: t}
	return result, nil
}

// Update updates an existing task
func (d *Daemon) Update(ctx context.Context, com *service.CommandUpdate) (*service.ResultUpdate, error) {
	if com.Task == nil {
		return nil, errors.New("failed to update a task because specified task is nil")
	}

	buf, err := json.Marshal(com.Task)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal specified task: %s", err.Error())
	}

	_, err = d.DB.Save(taskBucket, com.Task.Id, buf)
	if err != nil {
		return nil, fmt.Errorf("failed to save update of task: %s", err.Error())
	}

	return &service.ResultUpdate{
		Task: com.Task,
	}, nil
}

// Delete deletes an existing task
func (d *Daemon) Delete(ctx context.Context, com *service.CommandDelete) (*service.ResultDelete, error) {
	buf, err := d.DB.Load(taskBucket, com.Id)
	if err != nil {
		// TODO: error handling
	}

	t := &service.Task{Id: com.Id}
	err = json.Unmarshal(buf, t)
	if err != nil {
		// TODO: error handling
	}

	t.IsDeleted = true
	buf, err = json.Marshal(t)
	if err != nil {
		// TODO: error handling
	}

	_, err = d.DB.Save(taskBucket, com.Id, buf)
	return &service.ResultDelete{Task: t}, err
}

// Retrieve retrieves all existing tasks
func (d *Daemon) Retrieve(ctx context.Context, com *service.CommandRetrieve) (*service.ResultRetrieve, error) {
	tasks, err := d.retrieve()
	if err != nil {
		return nil, errors.New("failed to retrieve tasks: " + err.Error())
	}

	result := &service.ResultRetrieve{
		Tasks: tasks,
	}

	return result, err
}

func (d *Daemon) retrieve() ([]*service.Task, error) {
	tasks := make([]*service.Task, 0)

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if t.IsDeleted {
			return nil
		}

		tasks = append(tasks, t)
		return nil
	})
	if err != nil {
		return nil, err
	}

	return tasks, nil
}

// returns map[Place.String()][]*service.Task
func (d *Daemon) retrieveTaskMap() (map[string]map[string]*service.Task, error) {
	m := make(map[string]map[string]*service.Task, 0)
	for _, v := range places {
		m[v.String()] = make(map[string]*service.Task, 0)
	}

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if t.IsDeleted {
			return nil
		}

		m[t.Place.String()][t.Id] = t
		return nil
	})
	if err != nil {
		return nil, err
	}

	return m, nil
}

// UpdatePriority updates priority array
func (d *Daemon) UpdatePriority(ctx context.Context, com *service.CommandUpdatePriority) (*service.ResultUpdatePriority, error) {
	pmap, err := d.updatePriority(com.Priorities)
	priorities := make([]*service.Priority, len(pmap))
	var index int
	for _, v := range pmap {
		priorities[index] = v
		index++
	}
	return &service.ResultUpdatePriority{
		Priorities: priorities,
	}, err
}

func (d *Daemon) updatePriority(p []*service.Priority) (map[string]*service.Priority, error) {
	m := make(map[string]*service.Priority)

	for _, v := range p {
		m[v.Place.String()] = &service.Priority{
			Place: v.Place,
			Ids:   v.Ids,
		}
	}

	buf, err := json.Marshal(m)
	if err != nil {
		return nil, errors.New("failed to marshal CommandUpdatePriority into json: " + err.Error())
	}

	_, err = d.DB.Save(priorityBucket, "priority", buf)
	if err != nil {
		return nil, errors.New("failed to save priority on database: " + err.Error())
	}

	return m, nil
}

func lookupTaskByID(tasks map[string]map[string]*service.Task, id string) *service.Task {
	for _, t := range tasks {
		if _, ok := t[id]; ok {
			return t[id]
		}
	}
	return nil
}

// RetrievePriority returns priority array
func (d *Daemon) RetrievePriority(ctx context.Context, com *service.CommandRetrievePriority) (*service.ResultRetrievePriority, error) {
	pmap, err := d.retrievePriority()

	priorities := make([]*service.Priority, len(pmap))
	var index int
	for _, v := range pmap {
		priorities[index] = v
		index++
	}

	return &service.ResultRetrievePriority{Priorities: priorities}, err
}

func (d *Daemon) retrievePriority() (map[string]*service.Priority, error) {
	priorities, err := d.retrievePriorityMap()
	if err != nil {
		return nil, err
	}

	tasks, err := d.retrieveTaskMap()
	if err != nil {
		return nil, err
	}

	for _, priority := range priorities {
		for _, id := range priority.Ids {
			if lookupTaskByID(tasks, id) == nil {
				priority.Ids, _ = remove(priority.Ids, id)
			}
		}
	}

	for k := range tasks {
		if _, ok := priorities[k]; !ok {
			s := &service.Priority{
				Place: lookupPlaceByName[k],
			}
			s.Ids = make([]string, 0)
			priorities[k] = s
		}
		ids := priorities[k].Ids

		tasks := tasks[k]
		if len(ids) != len(tasks) {
			m := make(map[string]struct{})

			for i := range ids {
				for j := range tasks {
					if ids[i] == tasks[j].Id {
						m[ids[i]] = struct{}{}
					}
				}
			}

			if len(ids) < len(tasks) {
				// must cover lacked IDs
				for _, v := range tasks {
					if _, ok := m[v.Id]; ok {
						continue
					}

					ids = append(ids, v.Id)
				}
			}

			if len(ids) > len(tasks) {
				// must remove extra IDs
				for _, v := range ids {
					if _, ok := m[v]; ok {
						continue
					}

					ids, _ = remove(ids, v)
				}
			}
		}

		priorities[k].Ids = ids
	}

	return priorities, nil
}

func remove(ids []string, id string) ([]string, bool) {
	var removed bool
	var ret []string
	for _, v := range ids {
		if v == id {
			removed = true
			continue
		}
		ret = append(ret, v)
	}
	return ret, removed
}

func (d *Daemon) retrievePriorityMap() (map[string]*service.Priority, error) {
	m := make(map[string]*service.Priority)

	buf, err := d.DB.Load(priorityBucket, "priority")
	if err != nil {
		return nil, err
	}

	err = json.Unmarshal(buf, &m)
	if err != nil {
		log.Printf("failed to unmarshal loaded data into service.Priority: %s", err.Error())
	}

	return m, nil
}
