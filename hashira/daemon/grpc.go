package daemon

import (
	"context"
	"encoding/json"
	"errors"
	"log"

	"github.com/pankona/hashira/service"
)

const (
	taskBucket     = "taskBucket"
	priorityBucket = "priorityBucket"
)

var places = []service.Place{
	service.Place_BACKLOG,
	service.Place_TODO,
	service.Place_DOING,
	service.Place_DONE,
}

// Create creates a new task
func (d *Daemon) Create(ctx context.Context, cc *service.CommandCreate) (*service.ResultCreate, error) {
	t := &service.Task{
		Name:      cc.GetName(),
		Place:     service.Place_BACKLOG,
		IsDeleted: false,
	}
	buf, err := json.Marshal(t)
	if err != nil {
		return nil, errors.New("failed to create a new task: " + err.Error())
	}

	// specify empty id.
	// expect an id is automatically generated by database itself
	err = d.DB.Save(taskBucket, "", buf)
	if err != nil {
		return nil, errors.New("failed to save new task on database: " + err.Error())
	}

	result := &service.ResultCreate{Task: t}
	return result, nil
}

// Update updates an existing task
func (d *Daemon) Update(context.Context, *service.CommandUpdate) (*service.ResultUpdate, error) {
	// TODO: implement
	return nil, nil
}

// Delete deletes an existing task
func (d *Daemon) Delete(ctx context.Context, cd *service.CommandDelete) (*service.ResultDelete, error) {
	buf, err := d.DB.Load(taskBucket, cd.Id)
	if err != nil {
		// TODO: error handling
	}

	t := &service.Task{Id: cd.Id}
	err = json.Unmarshal(buf, t)
	if err != nil {
		// TODO: error handling
	}

	t.IsDeleted = true
	buf, err = json.Marshal(t)
	if err != nil {
		// TODO: error handling
	}

	return &service.ResultDelete{Task: t}, d.DB.Save(taskBucket, cd.Id, buf)
}

// Retrieve retrieves all existing tasks
func (d *Daemon) Retrieve(ctx context.Context, cr *service.CommandRetrieve) (*service.ResultRetrieve, error) {
	tasks, err := d.retrieve()
	if err != nil {
		return nil, errors.New("failed to retrieve tasks: " + err.Error())
	}

	result := &service.ResultRetrieve{
		Tasks: tasks,
	}

	return result, err
}

func (d *Daemon) retrieve() ([]*service.Task, error) {
	tasks := make([]*service.Task, 0)

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if t.IsDeleted {
			return nil
		}

		tasks = append(tasks, t)
		return nil
	})
	if err != nil {
		return nil, err
	}

	return tasks, nil
}

// returns map[Place.String()]*service.Task
func (d *Daemon) retrieveMap() (map[string][]*service.Task, error) {
	m := make(map[string][]*service.Task, 0)
	for _, v := range places {
		m[v.String()] = make([]*service.Task, 0)
	}

	err := d.DB.ForEach(taskBucket, func(k, v []byte) error {
		t := &service.Task{Id: string(k)}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}

		if t.IsDeleted {
			return nil
		}

		m[t.Place.String()] = append(m[t.Place.String()], t)
		return nil
	})
	if err != nil {
		return nil, err
	}

	return m, nil
}

func (d *Daemon) UpdatePriority(ctx context.Context, cup *service.CommandUpdatePriority) (*service.ResultUpdatePriority, error) {
	for _, v := range cup.Priorities {
		p := service.Priority{
			Place: v.Place,
			Ids:   v.Ids,
		}

		buf, err := json.Marshal(p)
		if err != nil {
			return nil, errors.New("failed to marshal CommandUpdatePriority into json: " + err.Error())
		}

		err = d.DB.Save(priorityBucket, v.Place.String(), buf)
		if err != nil {
			return nil, errors.New("failed to save priority on database: " + err.Error())
		}
	}

	priorities, err := d.retrievePriority()
	ret := make([]*service.Priority, 0)
	for _, v := range priorities {
		ret = append(ret, v)
	}

	return &service.ResultUpdatePriority{Priorities: ret}, err
}

func (d *Daemon) RetrievePriority(ctx context.Context, crp *service.CommandRetrievePriority) (*service.ResultRetrievePriority, error) {
	priorities, err := d.retrievePriority()
	if err != nil {
		return nil, err
	}

	tasks, err := d.retrieveMap()
	if err != nil {
		return nil, err
	}

	for k := range tasks {
		ids := priorities[k].Ids
		tasks := tasks[k]
		if len(ids) != len(tasks) {
			m := make(map[string]struct{})

			for i := range ids {
				for j := range tasks {
					if ids[i] == tasks[j].Id {
						m[ids[i]] = struct{}{}
					}
				}
			}

			if len(ids) < len(tasks) {
				// must cover lacked IDs
				for _, v := range tasks {
					if _, ok := m[v.Id]; ok {
						continue
					}

					priorities[k].Ids = append(priorities[k].Ids, v.Id)
				}
			}

			if len(ids) > len(tasks) {
				// must remove extra IDs
				for _, v := range ids {
					if _, ok := m[v]; ok {
						continue
					}

					priorities[k].Ids = remove(priorities[k].Ids, v)
				}
			}
		}
	}

	ret := make([]*service.Priority, 0)
	for _, v := range priorities {
		ret = append(ret, v)
	}

	log.Printf("priorities: %v", ret)

	return &service.ResultRetrievePriority{Priorities: ret}, err
}

func remove(ids []string, id string) []string {
	var ret []string
	for _, v := range ids {
		if v == id {
			continue
		}
		ret = append(ret, v)
	}
	return ret
}

func (d *Daemon) retrievePriority() (map[string]*service.Priority, error) {
	ret := make(map[string]*service.Priority)

	for _, v := range places {
		buf, err := d.DB.Load(priorityBucket, v.String())
		if err != nil {
			return nil, err
		}

		p := &service.Priority{}
		err = json.Unmarshal(buf, p)
		if err != nil {
			log.Printf("failed to unmarshal loaded data into service.Priority: %s", err.Error())
			p = &service.Priority{Place: v}
		}
		ret[v.String()] = p
	}

	return ret, nil
}
