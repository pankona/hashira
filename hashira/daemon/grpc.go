package daemon

import (
	"context"
	"encoding/json"
	"errors"

	"github.com/pankona/hashira/service"
)

func (d *Daemon) Create(ctx context.Context, cc *service.CommandCreate) (*service.ResultCreate, error) {
	t := &service.Task{
		Name:      cc.GetName(),
		Place:     service.Place_BACKLOG,
		IsDeleted: false,
	}
	buf, err := json.Marshal(t)
	if err != nil {
		return nil, errors.New("failed to create a new task: " + err.Error())
	}

	// specify empty id.
	// expect an id is automatically generated by database itself
	err = d.DB.Save("", buf)
	if err != nil {
		return nil, errors.New("failed to save new task on database: " + err.Error())
	}

	result := &service.ResultCreate{Task: t}
	return result, nil
}

func (d *Daemon) Update(context.Context, *service.CommandUpdate) (*service.ResultUpdate, error) {
	// TODO: implement
	return nil, nil
}

func (d *Daemon) Delete(context.Context, *service.CommandDelete) (*service.ResultDelete, error) {
	// TODO: implement
	return nil, nil
}

func (d *Daemon) Retrieve(ctx context.Context, cr *service.CommandRetrieve) (*service.ResultRetrieve, error) {
	tasks := make([]*service.Task, 0)
	err := d.DB.ForEach(func(k, v []byte) error {
		t := &service.Task{}
		err := json.Unmarshal(v, t)
		if err != nil {
			return errors.New("failed to retrieve tasks: " + err.Error())
		}
		tasks = append(tasks, t)
		return nil
	})
	if err != nil {
		return nil, errors.New("failed to retrieve tasks: " + err.Error())
	}
	result := &service.ResultRetrieve{
		Tasks: tasks,
	}
	return result, err
}
